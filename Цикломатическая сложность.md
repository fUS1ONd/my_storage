---
Time: 2025-03-11, 15:10
tags:
  - тестирование
  - оценка_сложности
---
### Тельце
*Определение.* Цикломатическая сложность - это программная метрика, используемая для обозначения сложности программы. Это количественная мера количества линейно независимых путей в исходном коде программы.

>Разработана Томасом Дж. МакКейбом-старшим в 1976.

Цикломатическая сложность части программного кода — количество линейно независимых маршрутов через [программный код](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4 "Исходный код"). Например, если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только единственный маршрут через код. Если код имеет единственный оператор `IF`, содержащий простое условие, то существует два пути через код: один если условие оператора `IF` имеет значение `TRUE` и один — если `FALSE`.

Есть две формулировки цикломатической сложности:
+ Математическая программы определяется с помощью [ориентированного графа](https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84 "Ориентированный граф"), узлами которого являются блоки программы, соединенные рёбрами, если управление может переходить с одного блока на другой. Тогда сложность определяется как:
	_M_ = _E_ − _N_ + 2P
	_M_ = цикломатическая сложность,
	_E_ = количество рёбер в графе,
	_N_ = количество узлов в графе,
	_P_ = количество [компонент связности](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%B0 "Компонента связности графа").
	![[Pasted image 20250311144021.png]]
+ В другой формулировке используется граф, в котором каждая точка выхода соединена с точкой входа. В этом случае граф является [сильносвязным](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84 "Связный граф"), и цикломатическая сложность программы равна [цикломатическому числу](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE "Цикломатическое число") этого графа (также известному как [первое число Бетти](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%91%D0%B5%D1%82%D1%82%D0%B8 "Число Бетти")), которое определяется как:
	_M_ = _E_ − _N_ + _P_.
	![[Pasted image 20250311144219.png]]

Может быть показано, что цикломатическая сложность любой структурированной программы с только одной точкой входа и одной точкой выхода эквивалентна числу точек ветвления (то есть, операторов `if` или условных циклов), содержащихся в этой программе, плюс один.

Цикломатическая сложность может быть распространена на программу с многочисленными точками выхода; в этом случае она равна:
	π − _s_ + 2,
	π — число точек ветвления в программе,
	_s_ — число точек выхода.

### Как относиться к цикломатической сложности?
Существует классификация цикломатической сложности, выдвинутая Томом МакКейбом:
	1 - 10: Простая процедура, небольшой риск
	11 - 20: Более сложный, умеренный риск
	21 - 50: Сложный, высокий риск
	> 50: Непроверяемый код, очень высокий риск